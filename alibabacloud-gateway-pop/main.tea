import SPI;
import Credential;
import OpenApi.OpenApiUtil;
import SignatureUtil;

extends SPI;

type @endpointSuffix = string
type @signatureTypePrefix = string
type @signPrefix = string
type @sha256 = string
type @sm3 = string

init() {
  super();
  // CLOUD4-
  @signatureTypePrefix = 'ACS4-';
  // cloud_v4
  @signPrefix = 'aliyun_v4';
  @endpointSuffix = 'aliyuncs.com';
  @sha256 = `${@signatureTypePrefix}HMAC-SHA256`;
  @sm3 = `${@signatureTypePrefix}HMAC-SM3`;
}

async function modifyConfiguration(context: SPI.InterceptorContext, attributeMap: SPI.AttributeMap): void {
  var request = context.request;
  var config = context.configuration;
  var attributes = attributeMap.key;
  if (!$isNull(attributes)) {
    @signatureTypePrefix = attributes.signatureTypePrefix;
    @signPrefix = attributes.signPrefix;
    @endpointSuffix = attributes.endpointSuffix;
    @sha256 = `${@signatureTypePrefix}HMAC-SHA256`;
    @sm3 = `${@signatureTypePrefix}HMAC-SM3`;
  }
  config.endpoint = getEndpoint(request.productId, config.regionId, config.endpointRule, config.network, config.suffix, config.endpointMap, config.endpoint);

}

async function modifyRequest(context: SPI.InterceptorContext, attributeMap: SPI.AttributeMap): void {
  var request = context.request;
  var config = context.configuration;
  var date = OpenApiUtil.getTimestamp();
  request.headers = {
    host = config.endpoint,
    x-acs-version = request.version,
    x-acs-action = request.action,
    user-agent = request.userAgent,
    x-acs-date = date,
    x-acs-signature-nonce = OpenApiUtil.getNonce(),
    accept = 'application/json',
    ...request.headers
  };
  var signatureAlgorithm : string = $string($default(request.signatureAlgorithm, @sha256));
  var hashedRequestPayload = OpenApiUtil.hash($Bytes.from('', 'utf8'), signatureAlgorithm);

  if (!$isNull(request.stream)) {
    var tmp = $Stream.readAsBytes(request.stream);
    hashedRequestPayload = OpenApiUtil.hash(tmp, signatureAlgorithm);
    request.stream = tmp;
    request.headers.content-type = 'application/octet-stream';
  } else {
    if (!$isNull(request.body)) {
      if (request.reqBodyType == 'json') {
        var jsonObj = $JSON.stringify(request.body);
        hashedRequestPayload = OpenApiUtil.hash($Bytes.from(jsonObj, 'utf8'), signatureAlgorithm);
        request.stream = jsonObj;
        request.headers.content-type = 'application/json; charset=utf-8';
      } else {
        var m = $object(request.body);
        var formObj = OpenApiUtil.toForm(m);
        hashedRequestPayload = OpenApiUtil.hash($Bytes.from(formObj, 'utf8'), signatureAlgorithm);
        request.stream = formObj;
        request.headers.content-type = 'application/x-www-form-urlencoded';
      }
    }
  }

  if (signatureAlgorithm == @sm3) {
    request.headers.x-acs-content-sm3 = hashedRequestPayload.toHex();
  } else {
    request.headers.x-acs-content-sha256 = hashedRequestPayload.toHex();
  }
  

  if (request.authType != 'Anonymous') {
    var credential : Credential = request.credential;
    if ($isNull(credential)) {
      throw {
        code = 'ParameterMissing',
        message = '\'config.credential\' can not be unset'
      };
    }

    var credentialModel = credential.getCredential();
    if ($isNull(credentialModel.providerName) && credentialModel.providerName != '') {
      request.headers.x-acs-credentials-provider = credentialModel.providerName;
    }
    var authType = credentialModel.type;
    if (authType == 'bearer') {
      var bearerToken = credential.getBearerToken();
      request.headers.x-acs-bearer-token = bearerToken;
      request.headers.x-acs-signature-type = 'BEARERTOKEN';
      request.headers.Authorization = `Bearer ${bearerToken}`;
    } else if (authType == 'id_token') {
      var idToken = credentialModel.securityToken;
      request.headers.x-acs-zero-trust-idtoken = idToken;
    } else {
      var accessKeyId = credentialModel.accessKeyId;
      var accessKeySecret = credentialModel.accessKeySecret;
      var securityToken = credentialModel.securityToken;

      if (!$isNull(securityToken) && securityToken != "") {
        request.headers.x-acs-accesskey-id = accessKeyId;
        request.headers.x-acs-security-token = securityToken;
      }
      var dateNew = date.subString(0, 10);
      dateNew = dateNew.replace('/-/g', '');
      var region = getRegion(request.productId, config.endpoint, config.regionId);
      var signingkey = getSigningkey(signatureAlgorithm, accessKeySecret, request.productId, region, dateNew);
      request.headers.Authorization = getAuthorization(request.pathname, request.method, request.query, request.headers, signatureAlgorithm, hashedRequestPayload.toHex(), accessKeyId, signingkey, request.productId, region, dateNew);
    }
    
  }
}

async function modifyResponse(context: SPI.InterceptorContext, attributeMap: SPI.AttributeMap): void {
  var request = context.request;
  var response = context.response;
  if ((response.statusCode >= 400) && (response.statusCode < 600)) {
    var _res = $Stream.readAsJSON(response.body);
    var err = $object(_res);
    var requestId = $default(err.RequestId, err.requestId);
    if (!$isNull(response.headers.x-acs-request-id)) {
      requestId = response.headers.x-acs-request-id;
    }
    err.statusCode = response.statusCode;
    throw {
      code = `${$default(err.Code, err.code)}`,
      message = `code: ${response.statusCode}, ${$default(err.Message, err.message)} request id: ${requestId}`,
      data = err,
      description = `${$default(err.Description, err.description)}`,
      accessDeniedDetail = $default(err.AccessDeniedDetail, err.accessDeniedDetail),
    };
  }
  if (response.statusCode == 204) {
      $Stream.readAsString(response.body);
  } else if (request.bodyType == 'binary') {
    response.deserializedBody = response.body;
  } else if (request.bodyType == 'byte') {
    var byt = $Stream.readAsBytes(response.body);
    response.deserializedBody = byt;
  } else if (request.bodyType == 'string') {
    var str = $Stream.readAsString(response.body);
    response.deserializedBody = str;
  } else if (request.bodyType == 'json') {
    var obj = $Stream.readAsJSON(response.body);
    var res = $object(obj);
    response.deserializedBody = res;
  } else if (request.bodyType == 'array') {
    var arr = $Stream.readAsJSON(response.body);
    response.deserializedBody = arr;
  } else {
    response.deserializedBody = $Stream.readAsString(response.body);
  }
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!$isNull(endpoint) && endpoint != '') {
    return endpoint;
  }

  if (!$isNull(endpointMap) && !$isNull(endpointMap[regionId]) && endpointMap[regionId] != '') {
    return endpointMap[regionId];
  }
  return OpenApiUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}

async function getAuthorization(pathname: string, method: string, query: map[string]string, headers: map[string]string, signatureAlgorithm: string, payload: string, ak: string, signingkey: bytes, product: string, region: string, date: string): string {
  var signature = getSignature(pathname, method, query, headers, signatureAlgorithm, payload, signingkey);
  var signedHeaders = getSignedHeaders(headers);
  var signedHeadersStr = signedHeaders.join(';');
  return `${signatureAlgorithm} Credential=${ak}/${date}/${region}/${product}/${@signPrefix}_request,SignedHeaders=${signedHeadersStr},Signature=${signature}`;
}

async function getSignature(pathname: string, method: string, query: map[string]string, headers: map[string]string, signatureAlgorithm: string, payload: string, signingkey: bytes): string {
  var canonicalURI : string = '/';
  if (!$isNull(pathname) && pathname != '') {
    canonicalURI = pathname;
  }
  var stringToSign : string = '';
  var canonicalizedResource = buildCanonicalizedResource(query);
  var canonicalizedHeaders = buildCanonicalizedHeaders(headers);
  var signedHeaders = getSignedHeaders(headers);
  var signedHeadersStr = signedHeaders.join(';');
  stringToSign = `${method}\n${canonicalURI}\n${canonicalizedResource}\n${canonicalizedHeaders}\n${signedHeadersStr}\n${payload}`;
  var hex = OpenApiUtil.hash($Bytes.from(stringToSign, 'utf8'), signatureAlgorithm);
  stringToSign = `${signatureAlgorithm}\n${hex.toHex()}`;
  var signature = $Bytes.from('', 'utf8');
  if (signatureAlgorithm == @sha256) {
    signature = SignatureUtil.HmacSHA256SignByBytes(stringToSign, signingkey);
  } else if (signatureAlgorithm == @sm3) {
    signature = SignatureUtil.HmacSM3SignByBytes(stringToSign, signingkey);
  }
  return signature.toHex();
}

async function getSigningkey(signatureAlgorithm: string, secret: string, product: string, region: string, date: string): bytes {
  var sc1 = `${@signPrefix}${secret}`;
  var sc2 = $Bytes.from('', 'utf8');
  if (signatureAlgorithm == @sha256) {
    sc2 = SignatureUtil.HmacSHA256Sign(date, sc1);
  } else if (signatureAlgorithm == @sm3) {
    sc2 = SignatureUtil.HmacSM3Sign(date, sc1);
  }
  var sc3 = $Bytes.from('', 'utf8');
  if (signatureAlgorithm == @sha256) {
    sc3 = SignatureUtil.HmacSHA256SignByBytes(region, sc2);
  } else if (signatureAlgorithm == @sm3) {
    sc3 = SignatureUtil.HmacSM3SignByBytes(region, sc2);
  }
  var sc4 = $Bytes.from('', 'utf8');
  if (signatureAlgorithm == @sha256) {
    sc4 = SignatureUtil.HmacSHA256SignByBytes(product, sc3);
  } else if (signatureAlgorithm == @sm3) {
    sc4 = SignatureUtil.HmacSM3SignByBytes(product, sc3);
  }
  var hmac = $Bytes.from('', 'utf8');
  if (signatureAlgorithm == @sha256) {
    hmac = SignatureUtil.HmacSHA256SignByBytes(`${@signPrefix}_request`, sc4);
  } else if (signatureAlgorithm == @sm3) {
    hmac = SignatureUtil.HmacSM3SignByBytes(`${@signPrefix}_request`, sc4);
  }
  return hmac;
}

function getRegion(product: string, endpoint: string, regionId: string): string {
  if (!$isNull(regionId) && regionId != '') {
    return regionId;
  }
  var region = 'center';
  if ((product == '') || (endpoint == '')) {
    return region;
  }
  var strs : [string] = endpoint.split(':');
  var withoutPort : string = strs[0];
  var preRegion: string = withoutPort.replace(`.${@endpointSuffix}`, '');
  var nodes = preRegion.split('.');
  if (nodes.length() == 2) {
    region = nodes[1];
  }
  return region;
}

async function buildCanonicalizedResource(query: map[string]string): string {
  var canonicalizedResource : string = '';
  if (!$isNull(query)) {
    var queryArray : [string] = query.keySet();
    var sortedQueryArray = queryArray.sort('asc');
    var separator : string = '';
    for(var key : sortedQueryArray) {
      canonicalizedResource = `${canonicalizedResource}${separator}${$URL.percentEncode(key)}`;
      if (!$isNull(query[key]) && query[key] != '') {
        canonicalizedResource = `${canonicalizedResource}=${$URL.percentEncode(query[key])}`;
      }
      separator = '&';
    }
  }
  return canonicalizedResource;
}

async function buildCanonicalizedHeaders(headers: map[string]string): string {
  var canonicalizedHeaders : string = '';
  var sortedHeaders : [string] = getSignedHeaders(headers);
  for(var header : sortedHeaders) {
    var headerValue = headers[header];
    canonicalizedHeaders = `${canonicalizedHeaders}${header}:${headerValue.trim()}\n`;
  }
  return canonicalizedHeaders;
}

async function getSignedHeaders(headers: map[string]string): [string] {
  var headersArray : [string] = headers.keySet();
  var sortedHeadersArray = headersArray.sort('asc');
  var tmp : string = '';
  var separator : string = '';
  for(var key : sortedHeadersArray) {
    var lowerKey = key.toLower();
    if (lowerKey.hasPrefix('x-acs-') || (lowerKey == 'host')
            || (lowerKey == 'content-type')) {
      if (!tmp.contains(lowerKey)) {
        tmp = `${tmp}${separator}${lowerKey}`;
        separator = ';';
      }
    }
  }
  return tmp.split(';');
}